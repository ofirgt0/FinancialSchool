export interface MetaDataModel {
    name: string;
    actions: any;
    defaults: any;
    path: string;
    children: any[];
}
/**
 * Ensures metadata is attached to the klass and returns it.
 */
export declare function ensureStoreMetadata(target: any): MetaDataModel;
/**
 * The generated function is faster than:
 * - pluck (Observable operator)
 * - memoize
 */
export declare function fastPropGetter(paths: string[]): (x: any) => any;
/**
 * Returns the type from a event class.
 */
export declare function getTypeFromKlass(event: any): any;
/**
 * Returns the type from a event instance.
 */
export declare function getTypeFromInstance(event: any): any;
/**
 * Given an array of states, it will return a object graph. Example:
 *    const states = [
 *      Cart,
 *      CartSaved,
 *      CartSavedItems
 *    ]
 *
 * would return:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 */
export declare function buildGraph(states: any): any;
/**
 * Given a states array, returns object graph
 * returning the name and state metadata. Example:
 *
 *  const graph = {
 *    cart: { metadata }
 *  };
 *
 */
export declare function nameToState(states: any): any;
/**
 * Given a object relationship graph will return the full path
 * for the child items. Example:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * would return:
 *
 *  const r = {
 *    cart: 'cart',
 *    saved: 'cart.saved',
 *    items: 'cart.saved.items'
 *  };
 *
 */
export declare function findFullParentPath(obj: any, newObj?: any): any;
/**
 * Given a object graph, it will return the items topologically sorted Example:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * would return:
 *
 *  const results = [
 *    'items',
 *    'saved',
 *    'cart'
 *  ];
 *
 */
export declare function topologicalSort(graph: any): any[];
/**
 * Set a deeply nested value. Example:
 *
 *   setValue({ foo: { bar: { eat: false } } },
 *      'foo.bar.eat', true) //=> { foo: { bar: { eat: true } } }
 *
 * While it traverses it also creates new objects from top down.
 */
export declare const setValue: (obj: any, prop: string, val: any) => any;
/**
 * Get a deeply nested value. Example:
 *
 *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
 *
 */
export declare const getValue: (obj: any, prop: string) => any;
/**
 * Returns if the parameter is a object or not.
 */
export declare function isObject(obj: any): boolean;
