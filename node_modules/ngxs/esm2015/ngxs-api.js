import { InjectionToken, Injector, Injectable, SkipSelf, Optional, Inject, ErrorHandler, NgModule } from '@angular/core';
import { BehaviorSubject } from 'rxjs/BehaviorSubject';
import { Observable } from 'rxjs/Observable';
import { distinctUntilChanged, catchError, take, filter } from 'rxjs/operators';
import { forkJoin } from 'rxjs/observable/forkJoin';
import { map } from 'rxjs/operators/map';
import { fromPromise } from 'rxjs/observable/fromPromise';
import { of } from 'rxjs/observable/of';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const ROOT_STATE_TOKEN = new InjectionToken('ROOT_STATE_TOKEN');
const FEATURE_STATE_TOKEN = new InjectionToken('FEATURE_STATE_TOKEN');
const META_KEY = 'NGXS_META';
/**
 * @record
 */

/**
 * @record
 * @template T
 */

/**
 * @record
 */

const NGXS_PLUGINS = new InjectionToken('NGXS_PLUGINS');
/**
 * @record
 * @template T
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @record
 */

/**
 * Ensures metadata is attached to the klass and returns it.
 * @param {?} target
 * @return {?}
 */
function ensureStoreMetadata(target) {
    if (!target.hasOwnProperty(META_KEY)) {
        const /** @type {?} */ defaultMetadata = {
            name: null,
            actions: {},
            defaults: {},
            path: null,
            children: []
        };
        Object.defineProperty(target, META_KEY, { value: defaultMetadata });
    }
    return target[META_KEY];
}
/**
 * The generated function is faster than:
 * - pluck (Observable operator)
 * - memoize
 * @param {?} paths
 * @return {?}
 */
function fastPropGetter(paths) {
    const /** @type {?} */ segments = paths;
    let /** @type {?} */ seg = 'store.' + segments[0];
    let /** @type {?} */ i = 0;
    const /** @type {?} */ l = segments.length;
    let /** @type {?} */ expr = seg;
    while (++i < l) {
        expr = expr + ' && ' + (seg = seg + '.' + segments[i]);
    }
    const /** @type {?} */ fn = new Function('store', 'return ' + expr + ';');
    return /** @type {?} */ (fn);
}
/**
 * Returns the type from a event class.
 * @param {?} event
 * @return {?}
 */
function getTypeFromKlass(event) {
    if (event.type) {
        return event.type;
    }
    else if (event.name) {
        return event.name;
    }
}
/**
 * Returns the type from a event instance.
 * @param {?} event
 * @return {?}
 */
function getTypeFromInstance(event) {
    if (event.constructor.type) {
        return event.constructor.type;
    }
    else if (event.constructor.name) {
        return event.constructor.name;
    }
    else if (event.type) {
        // events from dev tools are plain objects
        return event.type;
    }
}
/**
 * Given an array of states, it will return a object graph. Example:
 *    const states = [
 *      Cart,
 *      CartSaved,
 *      CartSavedItems
 *    ]
 *
 * would return:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * @param {?} states
 * @return {?}
 */
function buildGraph(states) {
    const /** @type {?} */ findName = klass => {
        const /** @type {?} */ meta = states.find(g => g === klass);
        if (!meta) {
            throw new Error(`Child state not found: ${klass}`);
        }
        if (!meta[META_KEY]) {
            throw new Error('States must be decorated with @State() decorator');
        }
        return meta[META_KEY].name;
    };
    return states.reduce((result, klass) => {
        if (!klass[META_KEY]) {
            throw new Error('States must be decorated with @State() decorator');
        }
        const { name, children } = klass[META_KEY];
        result[name] = (children || []).map(findName);
        return result;
    }, {});
}
/**
 * Given a states array, returns object graph
 * returning the name and state metadata. Example:
 *
 *  const graph = {
 *    cart: { metadata }
 *  };
 *
 * @param {?} states
 * @return {?}
 */
function nameToState(states) {
    return states.reduce((result, klass) => {
        if (!klass[META_KEY]) {
            throw new Error('States must be decorated with @State() decorator');
        }
        const /** @type {?} */ meta = klass[META_KEY];
        result[meta.name] = klass;
        return result;
    }, {});
}
/**
 * Given a object relationship graph will return the full path
 * for the child items. Example:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * would return:
 *
 *  const r = {
 *    cart: 'cart',
 *    saved: 'cart.saved',
 *    items: 'cart.saved.items'
 *  };
 *
 * @param {?} obj
 * @param {?=} newObj
 * @return {?}
 */
function findFullParentPath(obj, newObj = {}) {
    const /** @type {?} */ visit = (child, keyToFind) => {
        for (const /** @type {?} */ key in child) {
            if (child.hasOwnProperty(key) && child[key].indexOf(keyToFind) >= 0) {
                const /** @type {?} */ parent = visit(child, key);
                return parent !== null ? `${parent}.${key}` : key;
            }
        }
        return null;
    };
    for (const /** @type {?} */ key in obj) {
        if (obj.hasOwnProperty(key)) {
            const /** @type {?} */ parent = visit(obj, key);
            newObj[key] = parent ? `${parent}.${key}` : key;
        }
    }
    return newObj;
}
/**
 * Given a object graph, it will return the items topologically sorted Example:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * would return:
 *
 *  const results = [
 *    'items',
 *    'saved',
 *    'cart'
 *  ];
 *
 * @param {?} graph
 * @return {?}
 */
function topologicalSort(graph) {
    const /** @type {?} */ sorted = [];
    const /** @type {?} */ visited = {};
    const /** @type {?} */ visit = (name, ancestors = []) => {
        if (!Array.isArray(ancestors)) {
            ancestors = [];
        }
        ancestors.push(name);
        visited[name] = true;
        graph[name].forEach(dep => {
            if (ancestors.indexOf(dep) >= 0) {
                throw new Error(`Circular dependency '${dep}' is required by '${name}': ${ancestors.join(' -> ')}`);
            }
            if (visited[dep])
                return;
            visit(dep, ancestors.slice(0));
        });
        if (sorted.indexOf(name) < 0) {
            sorted.push(name);
        }
    };
    Object.keys(graph).forEach(k => visit(k));
    return sorted.reverse();
}
/**
 * Set a deeply nested value. Example:
 *
 *   setValue({ foo: { bar: { eat: false } } },
 *      'foo.bar.eat', true) //=> { foo: { bar: { eat: true } } }
 *
 * While it traverses it also creates new objects from top down.
 */
const setValue = (obj, prop, val) => {
    obj = Object.assign({}, obj);
    const /** @type {?} */ split = prop.split('.');
    const /** @type {?} */ last = split[split.length - 1];
    split.reduce((acc, part) => {
        if (part === last) {
            acc[part] = val;
        }
        else {
            acc[part] = Object.assign({}, acc[part]);
        }
        return acc && acc[part];
    }, obj);
    return obj;
};
/**
 * Get a deeply nested value. Example:
 *
 *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
 *
 */
const getValue = (obj, prop) => prop.split('.').reduce((acc, part) => acc && acc[part], obj);
/**
 * Returns if the parameter is a object or not.
 * @param {?} obj
 * @return {?}
 */
function isObject(obj) {
    return (typeof obj === 'object' && obj !== null) || typeof obj === 'function';
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class StateFactory {
    /**
     * @param {?} _injector
     * @param {?} _parentFactory
     */
    constructor(_injector, _parentFactory) {
        this._injector = _injector;
        this._parentFactory = _parentFactory;
        this._states = [];
    }
    /**
     * @return {?}
     */
    get states() {
        return this._parentFactory ? this._parentFactory.states : this._states;
    }
    /**
     * @param {?} states
     * @return {?}
     */
    add(states) {
        if (!Array.isArray(states)) {
            states = [states];
        }
        const /** @type {?} */ stateGraph = buildGraph(states);
        const /** @type {?} */ sortedStates = topologicalSort(stateGraph);
        const /** @type {?} */ depths = findFullParentPath(stateGraph);
        const /** @type {?} */ nameGraph = nameToState(states);
        const /** @type {?} */ mappedStores = [];
        for (const /** @type {?} */ name of sortedStates) {
            const /** @type {?} */ klass = nameGraph[name];
            if (!klass[META_KEY]) {
                throw new Error('States must be decorated with @State() decorator');
            }
            const /** @type {?} */ depth = depths[name];
            const { actions } = /** @type {?} */ (klass[META_KEY]);
            let { defaults } = /** @type {?} */ (klass[META_KEY]);
            (/** @type {?} */ (klass[META_KEY])).path = depth;
            // ensure our store hasn't already been added
            const /** @type {?} */ has = this.states.find(s => s.name === name);
            if (has) {
                throw new Error(`Store has already been added: ${name}`);
            }
            // create new instance of defaults
            if (Array.isArray(defaults)) {
                defaults = [...defaults];
            }
            else if (isObject(defaults)) {
                defaults = Object.assign({}, defaults);
            }
            else if (defaults === undefined) {
                defaults = {};
            }
            const /** @type {?} */ instance = this._injector.get(klass);
            mappedStores.push({
                actions,
                instance,
                defaults,
                name,
                depth
            });
        }
        this.states.push(...mappedStores);
        return mappedStores;
    }
    /**
     * @param {?} stores
     * @return {?}
     */
    addAndReturnDefaults(stores) {
        return this.add(stores).reduce((result, meta) => setValue(result, meta.depth, meta.defaults), {});
    }
    /**
     * @param {?} getState
     * @param {?} setState
     * @param {?} dispatch
     * @param {?} action
     * @return {?}
     */
    invokeActions(getState, setState, dispatch, action) {
        const /** @type {?} */ results = [];
        for (const /** @type {?} */ metadata of this.states) {
            const /** @type {?} */ name = getTypeFromInstance(action);
            const /** @type {?} */ actionMetas = metadata.actions[name];
            if (actionMetas) {
                for (const /** @type {?} */ actionMeta of actionMetas) {
                    const /** @type {?} */ stateContext = {
                        /**
                         * @return {?}
                         */
                        getState() {
                            const /** @type {?} */ state = getState();
                            return getValue(state, metadata.depth);
                        },
                        /**
                         * @param {?} val
                         * @return {?}
                         */
                        patchState(val) {
                            if (Array.isArray(val)) {
                                throw new Error('Patching arrays is not supported.');
                            }
                            let /** @type {?} */ state = getState();
                            const /** @type {?} */ local = getValue(state, metadata.depth);
                            for (const /** @type {?} */ k in val) {
                                local[k] = val[k];
                            }
                            state = setValue(state, metadata.depth, Object.assign({}, local));
                            setState(state);
                            return state;
                        },
                        /**
                         * @param {?} val
                         * @return {?}
                         */
                        setState(val) {
                            let /** @type {?} */ state = getState();
                            state = setValue(state, metadata.depth, val);
                            setState(state);
                            return state;
                        },
                        /**
                         * @param {?} actions
                         * @return {?}
                         */
                        dispatch(actions) {
                            return dispatch(actions);
                        }
                    };
                    const /** @type {?} */ result = metadata.instance[actionMeta.fn](stateContext, action);
                    if (result) {
                        results.push(result);
                    }
                }
            }
        }
        return results;
    }
}
StateFactory.decorators = [
    { type: Injectable },
];
/** @nocollapse */
StateFactory.ctorParameters = () => [
    { type: Injector, },
    { type: StateFactory, decorators: [{ type: Optional }, { type: SkipSelf },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Action stream that is emitted anytime an action is dispatched.
 * You can listen to this in services to react without stores.
 */
class Actions extends BehaviorSubject {
    /**
     * @param {?} parent
     */
    constructor(parent) {
        super({});
        if (parent) {
            Object.assign(this, parent);
        }
    }
}
Actions.decorators = [
    { type: Injectable },
];
/** @nocollapse */
Actions.ctorParameters = () => [
    { type: Actions, decorators: [{ type: Optional }, { type: SkipSelf },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Composes a array of functions from left to right. Example:
 *
 *      compose([fn, final])(state, action);
 *
 * then the funcs have a signature like:
 *
 *      function fn (state, action, next) {
 *          console.log('here', state, action, next);
 *          return next(state, action);
 *      }
 *
 *      function final (state, action) {
 *          console.log('here', state, action);
 *          return state;
 *      }
 *
 * the last function should not call `next`.
 */
const compose = funcs => (...args) => {
    const /** @type {?} */ curr = funcs.shift();
    return curr(...args, (...nextArgs) => compose(funcs)(...nextArgs));
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * BehaviorSubject of the entire state.
 */
class StateStream extends BehaviorSubject {
    /**
     * @param {?} parent
     */
    constructor(parent) {
        super({});
        if (parent) {
            Object.assign(this, parent);
        }
    }
}
StateStream.decorators = [
    { type: Injectable },
];
/** @nocollapse */
StateStream.ctorParameters = () => [
    { type: StateStream, decorators: [{ type: Optional }, { type: SkipSelf },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class PluginManager {
    /**
     * @param {?} _parentManager
     * @param {?} _plugins
     */
    constructor(_parentManager, _plugins) {
        this._parentManager = _parentManager;
        this._plugins = _plugins;
        this.plugins = [];
        this.register();
    }
    /**
     * @return {?}
     */
    register() {
        if (!this._plugins) {
            return;
        }
        this.plugins = this._plugins.map(plugin => {
            if (plugin.handle) {
                return plugin.handle.bind(plugin);
            }
            else {
                return plugin;
            }
        });
        if (this._parentManager) {
            this._parentManager.plugins.push(...this.plugins);
        }
    }
}
PluginManager.decorators = [
    { type: Injectable },
];
/** @nocollapse */
PluginManager.ctorParameters = () => [
    { type: PluginManager, decorators: [{ type: Optional }, { type: SkipSelf },] },
    { type: Array, decorators: [{ type: Inject, args: [NGXS_PLUGINS,] }, { type: Optional },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class Store {
    /**
     * @param {?} _errorHandler
     * @param {?} _actions
     * @param {?} _storeFactory
     * @param {?} _stateStream
     * @param {?} _pluginManager
     */
    constructor(_errorHandler, _actions, _storeFactory, _stateStream, _pluginManager) {
        this._errorHandler = _errorHandler;
        this._actions = _actions;
        this._storeFactory = _storeFactory;
        this._stateStream = _stateStream;
        this._pluginManager = _pluginManager;
    }
    /**
     * Dispatches event(s).
     * @param {?} event
     * @return {?}
     */
    dispatch(event) {
        let /** @type {?} */ result;
        if (Array.isArray(event)) {
            result = forkJoin(event.map(a => this._dispatch(a)));
        }
        else {
            result = this._dispatch(event);
        }
        result.pipe(catchError(err => {
            // handle error through angular error system
            this._errorHandler.handleError(err);
            return of(err);
        }));
        return result;
    }
    /**
     * @param {?} selector
     * @return {?}
     */
    select(selector) {
        if (selector[META_KEY] && selector[META_KEY].path) {
            const /** @type {?} */ getter = fastPropGetter(selector[META_KEY].path.split('.'));
            return this._stateStream.pipe(map(getter), distinctUntilChanged());
        }
        return this._stateStream.pipe(map(selector), distinctUntilChanged());
    }
    /**
     * @param {?} selector
     * @return {?}
     */
    selectOnce(selector) {
        return this.select(selector).pipe(take(1));
    }
    /**
     * Allow the user to subscribe to the root of the state
     * @param {?=} fn
     * @return {?}
     */
    subscribe(fn) {
        return this._stateStream.subscribe(fn);
    }
    /**
     * @param {?} action
     * @return {?}
     */
    _dispatch(action) {
        const /** @type {?} */ prevState = this._stateStream.getValue();
        const /** @type {?} */ plugins = this._pluginManager.plugins;
        return compose([
            ...plugins,
            (nextState, nextAction) => {
                if (nextState !== prevState) {
                    this._stateStream.next(nextState);
                }
                this._actions.next(nextAction);
                return this._dispatchActions(nextAction).pipe(map(() => this._stateStream.getValue()));
            }
        ])(prevState, action);
    }
    /**
     * @param {?} action
     * @return {?}
     */
    _dispatchActions(action) {
        const /** @type {?} */ results = this._storeFactory.invokeActions(() => this._stateStream.getValue(), newState => this._stateStream.next(newState), actions => this.dispatch(actions), action);
        return results.length ? forkJoin(this._handleNesting(results)) : of({}).pipe(take(1));
    }
    /**
     * @param {?} eventResults
     * @return {?}
     */
    _handleNesting(eventResults) {
        const /** @type {?} */ results = [];
        for (let /** @type {?} */ eventResult of eventResults) {
            if (eventResult instanceof Promise) {
                eventResult = fromPromise(eventResult);
            }
            if (eventResult instanceof Observable) {
                results.push(eventResult);
            }
        }
        return results;
    }
}
Store.decorators = [
    { type: Injectable },
];
/** @nocollapse */
Store.ctorParameters = () => [
    { type: ErrorHandler, },
    { type: Actions, },
    { type: StateFactory, },
    { type: StateStream, },
    { type: PluginManager, },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class SelectFactory {
    /**
     * @param {?} store
     */
    constructor(store) {
        SelectFactory.store = store;
    }
}
SelectFactory.store = undefined;
SelectFactory.decorators = [
    { type: Injectable },
];
/** @nocollapse */
SelectFactory.ctorParameters = () => [
    { type: Store, },
];
/**
 * Decorator for selecting a slice of state from the store.
 * @param {?=} selectorOrFeature
 * @param {...?} paths
 * @return {?}
 */
function Select(selectorOrFeature, ...paths) {
    return function (target, name) {
        const /** @type {?} */ selectorFnName = '__' + name + '__selector';
        if (!selectorOrFeature) {
            // if foo$ => make it just foo
            selectorOrFeature = name.lastIndexOf('$') === name.length - 1 ? name.substring(0, name.length - 1) : name;
        }
        const /** @type {?} */ createSelect = fn => {
            const /** @type {?} */ store = SelectFactory.store;
            if (!store) {
                throw new Error('SelectFactory not connected to store!');
            }
            return store.select(fn);
        };
        const /** @type {?} */ createSelector = () => {
            if (typeof selectorOrFeature === 'string') {
                const /** @type {?} */ propsArray = paths.length ? [selectorOrFeature, ...paths] : selectorOrFeature.split('.');
                return fastPropGetter(propsArray);
            }
            else if (selectorOrFeature[META_KEY] && selectorOrFeature[META_KEY].path) {
                return fastPropGetter(selectorOrFeature[META_KEY].path.split('.'));
            }
            else {
                return selectorOrFeature;
            }
        };
        if (target[selectorFnName]) {
            throw new Error('You cannot use @Select decorator and a ' + selectorFnName + ' property.');
        }
        if (delete target[name]) {
            Object.defineProperty(target, selectorFnName, {
                writable: true,
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(target, name, {
                get: function () {
                    return this[selectorFnName] || (this[selectorFnName] = createSelect.apply(this, [createSelector()]));
                },
                enumerable: true,
                configurable: true
            });
        }
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class InitState {
}
InitState.type = '@@INIT';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NgxsRootModule {
    /**
     * @param {?} _factory
     * @param {?} _stateStream
     * @param {?} store
     * @param {?} select
     * @param {?} states
     */
    constructor(_factory, _stateStream, store, select, states) {
        this._factory = _factory;
        this._stateStream = _stateStream;
        this.initStates(states);
        store.dispatch(new InitState());
    }
    /**
     * @param {?} states
     * @return {?}
     */
    initStates(states) {
        if (states) {
            // add stores to the state graph and return their defaults
            const /** @type {?} */ init = this._factory.addAndReturnDefaults(states);
            // get our current stream
            const /** @type {?} */ cur = this._stateStream.getValue();
            // set the state to the current + new
            this._stateStream.next(Object.assign({}, cur, init));
        }
    }
}
NgxsRootModule.decorators = [
    { type: NgModule },
];
/** @nocollapse */
NgxsRootModule.ctorParameters = () => [
    { type: StateFactory, },
    { type: StateStream, },
    { type: Store, },
    { type: SelectFactory, },
    { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [ROOT_STATE_TOKEN,] },] },
];
class NgxsFeatureModule {
    /**
     * @param {?} root
     * @param {?} store
     * @param {?} _stateStream
     * @param {?} _factory
     * @param {?} states
     */
    constructor(root, store, _stateStream, _factory, states) {
        this._stateStream = _stateStream;
        this._factory = _factory;
        // since FEATURE_STATE_TOKEN is a multi token, we need to flatten it [[Feature1State, Feature2State], [Feature3State]]
        const /** @type {?} */ flattenedStates = (/** @type {?} */ ([])).concat(...states);
        this.initStates(flattenedStates);
    }
    /**
     * @param {?} stores
     * @return {?}
     */
    initStates(stores) {
        if (stores) {
            // bind the stores
            const /** @type {?} */ init = this._factory.addAndReturnDefaults(stores);
            // get our current stream
            const /** @type {?} */ cur = this._stateStream.getValue();
            // set the state to the current + new
            this._stateStream.next(Object.assign({}, cur, init));
        }
    }
}
NgxsFeatureModule.decorators = [
    { type: NgModule, args: [{},] },
];
/** @nocollapse */
NgxsFeatureModule.ctorParameters = () => [
    { type: NgxsRootModule, },
    { type: Store, },
    { type: StateStream, },
    { type: StateFactory, },
    { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [FEATURE_STATE_TOKEN,] },] },
];
class NgxsModule {
    /**
     * @param {?=} states
     * @return {?}
     */
    static forRoot(states = []) {
        return {
            ngModule: NgxsRootModule,
            providers: [
                StateFactory,
                Actions,
                Store,
                StateStream,
                SelectFactory,
                PluginManager,
                ...states,
                {
                    provide: ROOT_STATE_TOKEN,
                    useValue: states
                }
            ]
        };
    }
    /**
     * @param {?} states
     * @return {?}
     */
    static forFeature(states) {
        return {
            ngModule: NgxsFeatureModule,
            providers: [
                StateFactory,
                PluginManager,
                ...states,
                {
                    provide: FEATURE_STATE_TOKEN,
                    multi: true,
                    useValue: states
                }
            ]
        };
    }
}
NgxsModule.decorators = [
    { type: NgModule, args: [{},] },
];
/** @nocollapse */
NgxsModule.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Decorates a method with a action information.
 * @param {?} actions
 * @return {?}
 */
function Action(actions) {
    return function (target, name, descriptor) {
        const /** @type {?} */ meta = ensureStoreMetadata(target.constructor);
        if (!Array.isArray(actions)) {
            actions = [actions];
        }
        for (const /** @type {?} */ action of actions) {
            const /** @type {?} */ type = getTypeFromKlass(action);
            if (!meta.actions[type]) {
                meta.actions[type] = [];
            }
            meta.actions[type].push({
                fn: name,
                type
            });
        }
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Decorates a class with ngxs state information.
 * @template T
 * @param {?} options
 * @return {?}
 */
function State(options) {
    return function (target) {
        const /** @type {?} */ meta = ensureStoreMetadata(target);
        // Handle inheritance
        if (target.__proto__.hasOwnProperty(META_KEY)) {
            const /** @type {?} */ parentMeta = target.__proto__[META_KEY];
            meta.actions = Object.assign({}, meta.actions, parentMeta.actions);
        }
        meta.children = options.children;
        meta.defaults = options.defaults;
        meta.name = options.name;
        if (!options.name) {
            throw new Error(`States must register a 'name' property`);
        }
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * RxJS operator for selecting out specific actions.
 * @param {...?} allowedTypes
 * @return {?}
 */
function ofAction(...allowedTypes) {
    const /** @type {?} */ allowedMap = {};
    allowedTypes.forEach(klass => (allowedMap[klass.type || klass.name] = true));
    return filter(action => {
        return allowedMap[action.constructor.type || action.constructor.name];
    });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Memoize a function.
 * Oringinally from: https://github.com/lodash/lodash/blob/master/memoize.js with some modifications
 * @param {?} func
 * @param {?=} resolver
 * @return {?}
 */
function memoize(func, resolver) {
    const /** @type {?} */ memoized = function (...args) {
        const /** @type {?} */ key = resolver ? resolver.apply(this, args) : args[0];
        const /** @type {?} */ cache = memoized.cache;
        if (cache.has(key)) {
            return cache.get(key);
        }
        const /** @type {?} */ result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
    };
    memoized.cache = new WeakMap();
    return memoized;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Decorator for memoizing a state selector.
 * @param {...?} args
 * @return {?}
 */
function Selector(...args) {
    return (target, key, descriptor) => {
        const /** @type {?} */ metadata = target[META_KEY];
        if (descriptor.value !== null) {
            const /** @type {?} */ prev = descriptor.value;
            const /** @type {?} */ fn = state => {
                const /** @type {?} */ local = getValue(state, metadata.path);
                return prev(local);
            };
            return {
                configurable: true,
                /**
                 * @return {?}
                 */
                get() {
                    return memoize.apply(null, [fn, ...args]);
                }
            };
        }
        else {
            throw new Error('Selectors only work on methods');
        }
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Interface for the redux-devtools-extension API.
 * @record
 */

/**
 * @record
 */

/**
 * @record
 */

const NGXS_DEVTOOLS_OPTIONS = new InjectionToken('NGXS_DEVTOOLS_OPTIONS');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Adds support for the Redux Devtools extension:
 * http://extension.remotedev.io/
 */
class NgxsReduxDevtoolsPlugin {
    /**
     * @param {?} _options
     * @param {?} _state
     */
    constructor(_options, _state) {
        this._options = _options;
        this._state = _state;
        this.devtoolsExtension = null;
        this.windowObj = typeof window !== 'undefined' ? window : {};
        const /** @type {?} */ globalDevtools = this.windowObj['__REDUX_DEVTOOLS_EXTENSION__'] || this.windowObj['devToolsExtension'];
        if (globalDevtools) {
            this.devtoolsExtension = /** @type {?} */ (globalDevtools.connect({
                name: 'NGXS',
                maxAge: _options.maxAge,
                actionSanitizer: _options.actionSanitizer,
                stateSanitizer: _options.stateSanitizer
            }));
            this.devtoolsExtension.subscribe(a => this.dispatched(a));
        }
    }
    /**
     * Middleware handle function
     * @param {?} state
     * @param {?} action
     * @param {?} next
     * @return {?}
     */
    handle(state, action, next) {
        const /** @type {?} */ isDisabled = this._options && this._options.disabled;
        if (!this.devtoolsExtension || isDisabled) {
            return next(state, action);
        }
        // process the state
        const /** @type {?} */ res = next(state, action);
        res.subscribe(newState => {
            // if init action, send initial state to dev tools
            const /** @type {?} */ isInitAction = getTypeFromInstance(action) === '@@INIT';
            if (isInitAction) {
                this.devtoolsExtension.init(state);
            }
            else {
                const /** @type {?} */ type = getTypeFromInstance(action);
                this.devtoolsExtension.send({ type, payload: action.payload }, newState);
            }
        });
        return res;
    }
    /**
     * Handle the action from the dev tools subscription
     * @param {?} action
     * @return {?}
     */
    dispatched(action) {
        if (action.type === 'DISPATCH') {
            if (action.payload.type === 'JUMP_TO_ACTION' || action.payload.type === 'JUMP_TO_STATE') {
                const /** @type {?} */ prevState = JSON.parse(action.state);
                this._state.next(prevState);
            }
            else if (action.payload.type === 'TOGGLE_ACTION') {
                // TODO
            }
        }
        else if (action.type === 'ACTION') {
            // TODO
            // const actionPayload = JSON.parse(action.payload);
            // this._store.dispatch(actionPayload);
        }
    }
}
NgxsReduxDevtoolsPlugin.decorators = [
    { type: Injectable },
];
/** @nocollapse */
NgxsReduxDevtoolsPlugin.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [NGXS_DEVTOOLS_OPTIONS,] },] },
    { type: StateStream, },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NgxsReduxDevtoolsPluginModule {
    /**
     * @param {?=} options
     * @return {?}
     */
    static forRoot(options) {
        return {
            ngModule: NgxsReduxDevtoolsPluginModule,
            providers: [
                { provide: NGXS_PLUGINS, useClass: NgxsReduxDevtoolsPlugin, multi: true },
                { provide: NGXS_DEVTOOLS_OPTIONS, useValue: options ? options : {} }
            ]
        };
    }
}
NgxsReduxDevtoolsPluginModule.decorators = [
    { type: NgModule, args: [{
                imports: [NgxsModule]
            },] },
];
/** @nocollapse */
NgxsReduxDevtoolsPluginModule.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @record
 */

const NGXS_LOGGER_PLUGIN_OPTIONS = new InjectionToken('NGXS_LOGGER_PLUGIN_OPTIONS');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const repeat = (str, times) => new Array(times + 1).join(str);
const pad = (num, maxLength) => repeat('0', maxLength - num.toString().length) + num;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NgxsLoggerPlugin {
    /**
     * @param {?} _options
     */
    constructor(_options) {
        this._options = _options;
    }
    /**
     * @param {?} state
     * @param {?} event
     * @param {?} next
     * @return {?}
     */
    handle(state, event, next) {
        const /** @type {?} */ options = this._options || /** @type {?} */ ({});
        const /** @type {?} */ logger = options.logger || console;
        const /** @type {?} */ actionName = getTypeFromInstance(event);
        const /** @type {?} */ time = new Date();
        // tslint:disable-next-line
        const /** @type {?} */ formattedTime = ` @ ${pad(time.getHours(), 2)}:${pad(time.getMinutes(), 2)}:${pad(time.getSeconds(), 2)}.${pad(time.getMilliseconds(), 3)}`;
        const /** @type {?} */ message = `action ${actionName}${formattedTime}`;
        const /** @type {?} */ startMessage = options.collapsed ? logger.groupCollapsed : logger.group;
        try {
            startMessage.call(logger, message);
        }
        catch (/** @type {?} */ e) {
            console.log(message);
        }
        if (typeof event.payload !== 'undefined') {
            logger.log('%c payload', 'color: #9E9E9E; font-weight: bold', event.payload);
        }
        logger.log('%c prev state', 'color: #9E9E9E; font-weight: bold', state);
        const /** @type {?} */ res = next(state, event);
        res.subscribe(nextState => {
            logger.log('%c next state', 'color: #4CAF50; font-weight: bold', nextState);
            try {
                logger.groupEnd();
            }
            catch (/** @type {?} */ e) {
                logger.log('—— log end ——');
            }
        });
        return res;
    }
}
NgxsLoggerPlugin.decorators = [
    { type: Injectable },
];
/** @nocollapse */
NgxsLoggerPlugin.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [NGXS_LOGGER_PLUGIN_OPTIONS,] },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NgxsLoggerPluginModule {
    /**
     * @param {?} options
     * @return {?}
     */
    static forRoot(options) {
        return {
            ngModule: NgxsLoggerPluginModule,
            providers: [
                {
                    provide: NGXS_PLUGINS,
                    useClass: NgxsLoggerPlugin,
                    multi: true
                },
                {
                    provide: NGXS_LOGGER_PLUGIN_OPTIONS,
                    useValue: Object.assign({
                        logger: console,
                        collapsed: false
                    }, options)
                }
            ]
        };
    }
}
NgxsLoggerPluginModule.decorators = [
    { type: NgModule },
];
/** @nocollapse */
NgxsLoggerPluginModule.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @record
 */

const NGXS_LOCAL_STORAGE_PLUGIN_OPTIONS = new InjectionToken('NGXS_LOCAL_STORAGE_PLUGIN_OPTION');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NgxsLocalStoragePlugin {
    /**
     * @param {?} _options
     */
    constructor(_options) {
        this._options = _options;
    }
    /**
     * @param {?} state
     * @param {?} event
     * @param {?} next
     * @return {?}
     */
    handle(state, event, next) {
        const /** @type {?} */ options = this._options || /** @type {?} */ ({});
        const /** @type {?} */ isInitAction = getTypeFromInstance(event) === '@@INIT';
        const /** @type {?} */ keys = Array.isArray(options.key) ? options.key : [options.key];
        const /** @type {?} */ engine = options.storage || localStorage;
        if (isInitAction) {
            for (const /** @type {?} */ key of keys) {
                let /** @type {?} */ val = engine.getItem(key);
                if (val !== 'undefined' && val !== null) {
                    val = options.deserialize(val);
                    if (key !== '@@STATE') {
                        state = setValue(state, key, val);
                    }
                    else {
                        state = val;
                    }
                }
            }
        }
        const /** @type {?} */ res = next(state, event);
        res.subscribe(nextState => {
            if (!isInitAction) {
                for (const /** @type {?} */ key of keys) {
                    let /** @type {?} */ val = nextState;
                    if (key !== '@@STATE') {
                        val = getValue(nextState, key);
                    }
                    engine.setItem(key, options.serialize(val));
                }
            }
        });
        return res;
    }
}
NgxsLocalStoragePlugin.decorators = [
    { type: Injectable },
];
/** @nocollapse */
NgxsLocalStoragePlugin.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [NGXS_LOCAL_STORAGE_PLUGIN_OPTIONS,] },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Default serialize function
 * @param {?} val
 * @return {?}
 */
function serialize(val) {
    return JSON.stringify(val);
}
/**
 * Default deserialize function
 * @param {?} val
 * @return {?}
 */
function deserialize(val) {
    return JSON.parse(val);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NgxsLocalStoragePluginModule {
    /**
     * @param {?=} options
     * @return {?}
     */
    static forRoot(options = {}) {
        return {
            ngModule: NgxsLocalStoragePluginModule,
            providers: [
                {
                    provide: NGXS_PLUGINS,
                    useClass: NgxsLocalStoragePlugin,
                    multi: true
                },
                {
                    provide: NGXS_LOCAL_STORAGE_PLUGIN_OPTIONS,
                    useValue: {
                        key: options.key || '@@STATE',
                        storage: localStorage,
                        serialize: options.serialize || serialize,
                        deserialize: options.deserialize || deserialize
                    }
                }
            ]
        };
    }
}
NgxsLocalStoragePluginModule.decorators = [
    { type: NgModule },
];
/** @nocollapse */
NgxsLocalStoragePluginModule.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Generated bundle index. Do not edit.
 */

export { NgxsModule, Action, Store, State, Select, Actions, ofAction, Selector, NgxsReduxDevtoolsPlugin, NgxsReduxDevtoolsPluginModule, NgxsLoggerPlugin, NgxsLoggerPluginModule, NgxsLocalStoragePlugin, NgxsLocalStoragePluginModule, NgxsFeatureModule as ɵb, NgxsRootModule as ɵa, PluginManager as ɵi, NGXS_DEVTOOLS_OPTIONS as ɵk, NGXS_LOCAL_STORAGE_PLUGIN_OPTIONS as ɵo, deserialize as ɵq, serialize as ɵp, NGXS_LOGGER_PLUGIN_OPTIONS as ɵm, SelectFactory as ɵc, StateFactory as ɵg, StateStream as ɵh, FEATURE_STATE_TOKEN as ɵe, NGXS_PLUGINS as ɵf, ROOT_STATE_TOKEN as ɵd };
//# sourceMappingURL=ngxs-api.js.map
