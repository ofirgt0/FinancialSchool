(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs/BehaviorSubject'), require('rxjs/Observable'), require('rxjs/operators'), require('rxjs/observable/forkJoin'), require('rxjs/operators/map'), require('rxjs/observable/fromPromise'), require('rxjs/observable/of')) :
	typeof define === 'function' && define.amd ? define(['exports', '@angular/core', 'rxjs/BehaviorSubject', 'rxjs/Observable', 'rxjs/operators', 'rxjs/observable/forkJoin', 'rxjs/operators/map', 'rxjs/observable/fromPromise', 'rxjs/observable/of'], factory) :
	(factory((global.ngxs = {}),global.ng.core,global.Rx,global.Rx,global.Rx.Observable.prototype,global.Rx.Observable,global.Rx.Observable.prototype,global.Rx.Observable,global.Rx.Observable));
}(this, (function (exports,core,BehaviorSubject,Observable,operators,forkJoin,map,fromPromise,of) { 'use strict';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0
THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.
See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */
var extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}








function __values(o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
}
function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}
function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

var ROOT_STATE_TOKEN = new core.InjectionToken('ROOT_STATE_TOKEN');
var FEATURE_STATE_TOKEN = new core.InjectionToken('FEATURE_STATE_TOKEN');
var META_KEY = 'NGXS_META';
var NGXS_PLUGINS = new core.InjectionToken('NGXS_PLUGINS');
function ensureStoreMetadata(target) {
    if (!target.hasOwnProperty(META_KEY)) {
        var defaultMetadata = {
            name: null,
            actions: {},
            defaults: {},
            path: null,
            children: []
        };
        Object.defineProperty(target, META_KEY, { value: defaultMetadata });
    }
    return target[META_KEY];
}
function fastPropGetter(paths) {
    var segments = paths;
    var seg = 'store.' + segments[0];
    var i = 0;
    var l = segments.length;
    var expr = seg;
    while (++i < l) {
        expr = expr + ' && ' + (seg = seg + '.' + segments[i]);
    }
    var fn = new Function('store', 'return ' + expr + ';');
    return (fn);
}
function getTypeFromKlass(event) {
    if (event.type) {
        return event.type;
    }
    else if (event.name) {
        return event.name;
    }
}
function getTypeFromInstance(event) {
    if (event.constructor.type) {
        return event.constructor.type;
    }
    else if (event.constructor.name) {
        return event.constructor.name;
    }
    else if (event.type) {
        return event.type;
    }
}
function buildGraph(states) {
    var findName = function (klass) {
        var meta = states.find(function (g) { return g === klass; });
        if (!meta) {
            throw new Error("Child state not found: " + klass);
        }
        if (!meta[META_KEY]) {
            throw new Error('States must be decorated with @State() decorator');
        }
        return meta[META_KEY].name;
    };
    return states.reduce(function (result, klass) {
        if (!klass[META_KEY]) {
            throw new Error('States must be decorated with @State() decorator');
        }
        var _a = klass[META_KEY], name = _a.name, children = _a.children;
        result[name] = (children || []).map(findName);
        return result;
    }, {});
}
function nameToState(states) {
    return states.reduce(function (result, klass) {
        if (!klass[META_KEY]) {
            throw new Error('States must be decorated with @State() decorator');
        }
        var meta = klass[META_KEY];
        result[meta.name] = klass;
        return result;
    }, {});
}
function findFullParentPath(obj, newObj) {
    if (newObj === void 0) { newObj = {}; }
    var visit = function (child, keyToFind) {
        for (var key in child) {
            if (child.hasOwnProperty(key) && child[key].indexOf(keyToFind) >= 0) {
                var parent = visit(child, key);
                return parent !== null ? parent + "." + key : key;
            }
        }
        return null;
    };
    for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
            var parent = visit(obj, key);
            newObj[key] = parent ? parent + "." + key : key;
        }
    }
    return newObj;
}
function topologicalSort(graph) {
    var sorted = [];
    var visited = {};
    var visit = function (name, ancestors) {
        if (ancestors === void 0) { ancestors = []; }
        if (!Array.isArray(ancestors)) {
            ancestors = [];
        }
        ancestors.push(name);
        visited[name] = true;
        graph[name].forEach(function (dep) {
            if (ancestors.indexOf(dep) >= 0) {
                throw new Error("Circular dependency '" + dep + "' is required by '" + name + "': " + ancestors.join(' -> '));
            }
            if (visited[dep])
                return;
            visit(dep, ancestors.slice(0));
        });
        if (sorted.indexOf(name) < 0) {
            sorted.push(name);
        }
    };
    Object.keys(graph).forEach(function (k) { return visit(k); });
    return sorted.reverse();
}
var setValue = function (obj, prop, val) {
    obj = Object.assign({}, obj);
    var split = prop.split('.');
    var last = split[split.length - 1];
    split.reduce(function (acc, part) {
        if (part === last) {
            acc[part] = val;
        }
        else {
            acc[part] = Object.assign({}, acc[part]);
        }
        return acc && acc[part];
    }, obj);
    return obj;
};
var getValue = function (obj, prop) { return prop.split('.').reduce(function (acc, part) { return acc && acc[part]; }, obj); };
function isObject(obj) {
    return (typeof obj === 'object' && obj !== null) || typeof obj === 'function';
}
var StateFactory = /** @class */ (function () {
    function StateFactory(_injector, _parentFactory) {
        this._injector = _injector;
        this._parentFactory = _parentFactory;
        this._states = [];
    }
    Object.defineProperty(StateFactory.prototype, "states", {
        get: function () {
            return this._parentFactory ? this._parentFactory.states : this._states;
        },
        enumerable: true,
        configurable: true
    });
    StateFactory.prototype.add = function (states) {
        if (!Array.isArray(states)) {
            states = [states];
        }
        var stateGraph = buildGraph(states);
        var sortedStates = topologicalSort(stateGraph);
        var depths = findFullParentPath(stateGraph);
        var nameGraph = nameToState(states);
        var mappedStores = [];
        var _loop_1 = function (name) {
            var klass = nameGraph[name];
            if (!klass[META_KEY]) {
                throw new Error('States must be decorated with @State() decorator');
            }
            var depth = depths[name];
            var actions = (klass[META_KEY]).actions;
            var defaults = (klass[META_KEY]).defaults;
            ((klass[META_KEY])).path = depth;
            var has = this_1.states.find(function (s) { return s.name === name; });
            if (has) {
                throw new Error("Store has already been added: " + name);
            }
            if (Array.isArray(defaults)) {
                defaults = __spread(defaults);
            }
            else if (isObject(defaults)) {
                defaults = Object.assign({}, defaults);
            }
            else if (defaults === undefined) {
                defaults = {};
            }
            var instance = this_1._injector.get(klass);
            mappedStores.push({
                actions: actions,
                instance: instance,
                defaults: defaults,
                name: name,
                depth: depth
            });
        };
        var this_1 = this;
        try {
            for (var sortedStates_1 = __values(sortedStates), sortedStates_1_1 = sortedStates_1.next(); !sortedStates_1_1.done; sortedStates_1_1 = sortedStates_1.next()) {
                var name = sortedStates_1_1.value;
                _loop_1(name);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (sortedStates_1_1 && !sortedStates_1_1.done && (_a = sortedStates_1.return)) _a.call(sortedStates_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        (_b = this.states).push.apply(_b, __spread(mappedStores));
        return mappedStores;
        var e_1, _a, _b;
    };
    StateFactory.prototype.addAndReturnDefaults = function (stores) {
        return this.add(stores).reduce(function (result, meta) { return setValue(result, meta.depth, meta.defaults); }, {});
    };
    StateFactory.prototype.invokeActions = function (getState, setState, dispatch, action) {
        var results = [];
        var _loop_2 = function (metadata) {
            var name = getTypeFromInstance(action);
            var actionMetas = metadata.actions[name];
            if (actionMetas) {
                try {
                    for (var actionMetas_1 = __values(actionMetas), actionMetas_1_1 = actionMetas_1.next(); !actionMetas_1_1.done; actionMetas_1_1 = actionMetas_1.next()) {
                        var actionMeta = actionMetas_1_1.value;
                        var stateContext = {
                            getState: function () {
                                var state = getState();
                                return getValue(state, metadata.depth);
                            },
                            patchState: function (val) {
                                if (Array.isArray(val)) {
                                    throw new Error('Patching arrays is not supported.');
                                }
                                var state = getState();
                                var local = getValue(state, metadata.depth);
                                for (var k in val) {
                                    local[k] = val[k];
                                }
                                state = setValue(state, metadata.depth, Object.assign({}, local));
                                setState(state);
                                return state;
                            },
                            setState: function (val) {
                                var state = getState();
                                state = setValue(state, metadata.depth, val);
                                setState(state);
                                return state;
                            },
                            dispatch: function (actions) {
                                return dispatch(actions);
                            }
                        };
                        var result = metadata.instance[actionMeta.fn](stateContext, action);
                        if (result) {
                            results.push(result);
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (actionMetas_1_1 && !actionMetas_1_1.done && (_a = actionMetas_1.return)) _a.call(actionMetas_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
            var e_2, _a;
        };
        try {
            for (var _a = __values(this.states), _b = _a.next(); !_b.done; _b = _a.next()) {
                var metadata = _b.value;
                _loop_2(metadata);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return results;
        var e_3, _c;
    };
    return StateFactory;
}());
StateFactory.decorators = [
    { type: core.Injectable },
];
StateFactory.ctorParameters = function () { return [
    { type: core.Injector, },
    { type: StateFactory, decorators: [{ type: core.Optional }, { type: core.SkipSelf },] },
]; };
var Actions = /** @class */ (function (_super) {
    __extends(Actions, _super);
    function Actions(parent) {
        var _this = _super.call(this, {}) || this;
        if (parent) {
            Object.assign(_this, parent);
        }
        return _this;
    }
    return Actions;
}(BehaviorSubject.BehaviorSubject));
Actions.decorators = [
    { type: core.Injectable },
];
Actions.ctorParameters = function () { return [
    { type: Actions, decorators: [{ type: core.Optional }, { type: core.SkipSelf },] },
]; };
var compose = function (funcs) { return function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var curr = funcs.shift();
    return curr.apply(void 0, __spread(args, [function () {
            var nextArgs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                nextArgs[_i] = arguments[_i];
            }
            return compose(funcs).apply(void 0, __spread(nextArgs));
        }]));
}; };
var StateStream = /** @class */ (function (_super) {
    __extends(StateStream, _super);
    function StateStream(parent) {
        var _this = _super.call(this, {}) || this;
        if (parent) {
            Object.assign(_this, parent);
        }
        return _this;
    }
    return StateStream;
}(BehaviorSubject.BehaviorSubject));
StateStream.decorators = [
    { type: core.Injectable },
];
StateStream.ctorParameters = function () { return [
    { type: StateStream, decorators: [{ type: core.Optional }, { type: core.SkipSelf },] },
]; };
var PluginManager = /** @class */ (function () {
    function PluginManager(_parentManager, _plugins) {
        this._parentManager = _parentManager;
        this._plugins = _plugins;
        this.plugins = [];
        this.register();
    }
    PluginManager.prototype.register = function () {
        if (!this._plugins) {
            return;
        }
        this.plugins = this._plugins.map(function (plugin) {
            if (plugin.handle) {
                return plugin.handle.bind(plugin);
            }
            else {
                return plugin;
            }
        });
        if (this._parentManager) {
            (_a = this._parentManager.plugins).push.apply(_a, __spread(this.plugins));
        }
        var _a;
    };
    return PluginManager;
}());
PluginManager.decorators = [
    { type: core.Injectable },
];
PluginManager.ctorParameters = function () { return [
    { type: PluginManager, decorators: [{ type: core.Optional }, { type: core.SkipSelf },] },
    { type: Array, decorators: [{ type: core.Inject, args: [NGXS_PLUGINS,] }, { type: core.Optional },] },
]; };
var Store = /** @class */ (function () {
    function Store(_errorHandler, _actions, _storeFactory, _stateStream, _pluginManager) {
        this._errorHandler = _errorHandler;
        this._actions = _actions;
        this._storeFactory = _storeFactory;
        this._stateStream = _stateStream;
        this._pluginManager = _pluginManager;
    }
    Store.prototype.dispatch = function (event) {
        var _this = this;
        var result;
        if (Array.isArray(event)) {
            result = forkJoin.forkJoin(event.map(function (a) { return _this._dispatch(a); }));
        }
        else {
            result = this._dispatch(event);
        }
        result.pipe(operators.catchError(function (err) {
            _this._errorHandler.handleError(err);
            return of.of(err);
        }));
        return result;
    };
    Store.prototype.select = function (selector) {
        if (selector[META_KEY] && selector[META_KEY].path) {
            var getter = fastPropGetter(selector[META_KEY].path.split('.'));
            return this._stateStream.pipe(map.map(getter), operators.distinctUntilChanged());
        }
        return this._stateStream.pipe(map.map(selector), operators.distinctUntilChanged());
    };
    Store.prototype.selectOnce = function (selector) {
        return this.select(selector).pipe(operators.take(1));
    };
    Store.prototype.subscribe = function (fn) {
        return this._stateStream.subscribe(fn);
    };
    Store.prototype._dispatch = function (action) {
        var _this = this;
        var prevState = this._stateStream.getValue();
        var plugins = this._pluginManager.plugins;
        return compose(__spread(plugins, [
            function (nextState, nextAction) {
                if (nextState !== prevState) {
                    _this._stateStream.next(nextState);
                }
                _this._actions.next(nextAction);
                return _this._dispatchActions(nextAction).pipe(map.map(function () { return _this._stateStream.getValue(); }));
            }
        ]))(prevState, action);
    };
    Store.prototype._dispatchActions = function (action) {
        var _this = this;
        var results = this._storeFactory.invokeActions(function () { return _this._stateStream.getValue(); }, function (newState) { return _this._stateStream.next(newState); }, function (actions) { return _this.dispatch(actions); }, action);
        return results.length ? forkJoin.forkJoin(this._handleNesting(results)) : of.of({}).pipe(operators.take(1));
    };
    Store.prototype._handleNesting = function (eventResults) {
        var results = [];
        try {
            for (var eventResults_1 = __values(eventResults), eventResults_1_1 = eventResults_1.next(); !eventResults_1_1.done; eventResults_1_1 = eventResults_1.next()) {
                var eventResult = eventResults_1_1.value;
                if (eventResult instanceof Promise) {
                    eventResult = fromPromise.fromPromise(eventResult);
                }
                if (eventResult instanceof Observable.Observable) {
                    results.push(eventResult);
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (eventResults_1_1 && !eventResults_1_1.done && (_a = eventResults_1.return)) _a.call(eventResults_1);
            }
            finally { if (e_4) throw e_4.error; }
        }
        return results;
        var e_4, _a;
    };
    return Store;
}());
Store.decorators = [
    { type: core.Injectable },
];
Store.ctorParameters = function () { return [
    { type: core.ErrorHandler, },
    { type: Actions, },
    { type: StateFactory, },
    { type: StateStream, },
    { type: PluginManager, },
]; };
var SelectFactory = /** @class */ (function () {
    function SelectFactory(store) {
        SelectFactory.store = store;
    }
    return SelectFactory;
}());
SelectFactory.store = undefined;
SelectFactory.decorators = [
    { type: core.Injectable },
];
SelectFactory.ctorParameters = function () { return [
    { type: Store, },
]; };
function Select(selectorOrFeature) {
    var paths = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        paths[_i - 1] = arguments[_i];
    }
    return function (target, name) {
        var selectorFnName = '__' + name + '__selector';
        if (!selectorOrFeature) {
            selectorOrFeature = name.lastIndexOf('$') === name.length - 1 ? name.substring(0, name.length - 1) : name;
        }
        var createSelect = function (fn) {
            var store = SelectFactory.store;
            if (!store) {
                throw new Error('SelectFactory not connected to store!');
            }
            return store.select(fn);
        };
        var createSelector = function () {
            if (typeof selectorOrFeature === 'string') {
                var propsArray = paths.length ? __spread([selectorOrFeature], paths) : selectorOrFeature.split('.');
                return fastPropGetter(propsArray);
            }
            else if (selectorOrFeature[META_KEY] && selectorOrFeature[META_KEY].path) {
                return fastPropGetter(selectorOrFeature[META_KEY].path.split('.'));
            }
            else {
                return selectorOrFeature;
            }
        };
        if (target[selectorFnName]) {
            throw new Error('You cannot use @Select decorator and a ' + selectorFnName + ' property.');
        }
        if (delete target[name]) {
            Object.defineProperty(target, selectorFnName, {
                writable: true,
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(target, name, {
                get: function () {
                    return this[selectorFnName] || (this[selectorFnName] = createSelect.apply(this, [createSelector()]));
                },
                enumerable: true,
                configurable: true
            });
        }
    };
}
var InitState = /** @class */ (function () {
    function InitState() {
    }
    return InitState;
}());
InitState.type = '@@INIT';
var NgxsRootModule = /** @class */ (function () {
    function NgxsRootModule(_factory, _stateStream, store, select, states) {
        this._factory = _factory;
        this._stateStream = _stateStream;
        this.initStates(states);
        store.dispatch(new InitState());
    }
    NgxsRootModule.prototype.initStates = function (states) {
        if (states) {
            var init = this._factory.addAndReturnDefaults(states);
            var cur = this._stateStream.getValue();
            this._stateStream.next(Object.assign({}, cur, init));
        }
    };
    return NgxsRootModule;
}());
NgxsRootModule.decorators = [
    { type: core.NgModule },
];
NgxsRootModule.ctorParameters = function () { return [
    { type: StateFactory, },
    { type: StateStream, },
    { type: Store, },
    { type: SelectFactory, },
    { type: Array, decorators: [{ type: core.Optional }, { type: core.Inject, args: [ROOT_STATE_TOKEN,] },] },
]; };
var NgxsFeatureModule = /** @class */ (function () {
    function NgxsFeatureModule(root, store, _stateStream, _factory, states) {
        this._stateStream = _stateStream;
        this._factory = _factory;
        var flattenedStates = (([])).concat.apply((([])), __spread(states));
        this.initStates(flattenedStates);
    }
    NgxsFeatureModule.prototype.initStates = function (stores) {
        if (stores) {
            var init = this._factory.addAndReturnDefaults(stores);
            var cur = this._stateStream.getValue();
            this._stateStream.next(Object.assign({}, cur, init));
        }
    };
    return NgxsFeatureModule;
}());
NgxsFeatureModule.decorators = [
    { type: core.NgModule, args: [{},] },
];
NgxsFeatureModule.ctorParameters = function () { return [
    { type: NgxsRootModule, },
    { type: Store, },
    { type: StateStream, },
    { type: StateFactory, },
    { type: Array, decorators: [{ type: core.Optional }, { type: core.Inject, args: [FEATURE_STATE_TOKEN,] },] },
]; };
var NgxsModule = /** @class */ (function () {
    function NgxsModule() {
    }
    NgxsModule.forRoot = function (states) {
        if (states === void 0) { states = []; }
        return {
            ngModule: NgxsRootModule,
            providers: __spread([
                StateFactory,
                Actions,
                Store,
                StateStream,
                SelectFactory,
                PluginManager
            ], states, [
                {
                    provide: ROOT_STATE_TOKEN,
                    useValue: states
                }
            ])
        };
    };
    NgxsModule.forFeature = function (states) {
        return {
            ngModule: NgxsFeatureModule,
            providers: __spread([
                StateFactory,
                PluginManager
            ], states, [
                {
                    provide: FEATURE_STATE_TOKEN,
                    multi: true,
                    useValue: states
                }
            ])
        };
    };
    return NgxsModule;
}());
NgxsModule.decorators = [
    { type: core.NgModule, args: [{},] },
];
NgxsModule.ctorParameters = function () { return []; };
function Action(actions) {
    return function (target, name, descriptor) {
        var meta = ensureStoreMetadata(target.constructor);
        if (!Array.isArray(actions)) {
            actions = [actions];
        }
        try {
            for (var actions_1 = __values(actions), actions_1_1 = actions_1.next(); !actions_1_1.done; actions_1_1 = actions_1.next()) {
                var action = actions_1_1.value;
                var type = getTypeFromKlass(action);
                if (!meta.actions[type]) {
                    meta.actions[type] = [];
                }
                meta.actions[type].push({
                    fn: name,
                    type: type
                });
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (actions_1_1 && !actions_1_1.done && (_a = actions_1.return)) _a.call(actions_1);
            }
            finally { if (e_5) throw e_5.error; }
        }
        var e_5, _a;
    };
}
function State(options) {
    return function (target) {
        var meta = ensureStoreMetadata(target);
        if (target.__proto__.hasOwnProperty(META_KEY)) {
            var parentMeta = target.__proto__[META_KEY];
            meta.actions = Object.assign({}, meta.actions, parentMeta.actions);
        }
        meta.children = options.children;
        meta.defaults = options.defaults;
        meta.name = options.name;
        if (!options.name) {
            throw new Error("States must register a 'name' property");
        }
    };
}
function ofAction() {
    var allowedTypes = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        allowedTypes[_i] = arguments[_i];
    }
    var allowedMap = {};
    allowedTypes.forEach(function (klass) { return (allowedMap[klass.type || klass.name] = true); });
    return operators.filter(function (action) {
        return allowedMap[action.constructor.type || action.constructor.name];
    });
}
function memoize(func, resolver) {
    var memoized = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var key = resolver ? resolver.apply(this, args) : args[0];
        var cache = memoized.cache;
        if (cache.has(key)) {
            return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
    };
    memoized.cache = new WeakMap();
    return memoized;
}
function Selector() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return function (target, key, descriptor) {
        var metadata = target[META_KEY];
        if (descriptor.value !== null) {
            var prev_1 = descriptor.value;
            var fn_1 = function (state) {
                var local = getValue(state, metadata.path);
                return prev_1(local);
            };
            return {
                configurable: true,
                get: function () {
                    return memoize.apply(null, __spread([fn_1], args));
                }
            };
        }
        else {
            throw new Error('Selectors only work on methods');
        }
    };
}
var NGXS_DEVTOOLS_OPTIONS = new core.InjectionToken('NGXS_DEVTOOLS_OPTIONS');
var NgxsReduxDevtoolsPlugin = /** @class */ (function () {
    function NgxsReduxDevtoolsPlugin(_options, _state) {
        var _this = this;
        this._options = _options;
        this._state = _state;
        this.devtoolsExtension = null;
        this.windowObj = typeof window !== 'undefined' ? window : {};
        var globalDevtools = this.windowObj['__REDUX_DEVTOOLS_EXTENSION__'] || this.windowObj['devToolsExtension'];
        if (globalDevtools) {
            this.devtoolsExtension = (globalDevtools.connect({
                name: 'NGXS',
                maxAge: _options.maxAge,
                actionSanitizer: _options.actionSanitizer,
                stateSanitizer: _options.stateSanitizer
            }));
            this.devtoolsExtension.subscribe(function (a) { return _this.dispatched(a); });
        }
    }
    NgxsReduxDevtoolsPlugin.prototype.handle = function (state, action, next) {
        var _this = this;
        var isDisabled = this._options && this._options.disabled;
        if (!this.devtoolsExtension || isDisabled) {
            return next(state, action);
        }
        var res = next(state, action);
        res.subscribe(function (newState) {
            var isInitAction = getTypeFromInstance(action) === '@@INIT';
            if (isInitAction) {
                _this.devtoolsExtension.init(state);
            }
            else {
                var type = getTypeFromInstance(action);
                _this.devtoolsExtension.send({ type: type, payload: action.payload }, newState);
            }
        });
        return res;
    };
    NgxsReduxDevtoolsPlugin.prototype.dispatched = function (action) {
        if (action.type === 'DISPATCH') {
            if (action.payload.type === 'JUMP_TO_ACTION' || action.payload.type === 'JUMP_TO_STATE') {
                var prevState = JSON.parse(action.state);
                this._state.next(prevState);
            }
            else if (action.payload.type === 'TOGGLE_ACTION') {
            }
        }
        else if (action.type === 'ACTION') {
        }
    };
    return NgxsReduxDevtoolsPlugin;
}());
NgxsReduxDevtoolsPlugin.decorators = [
    { type: core.Injectable },
];
NgxsReduxDevtoolsPlugin.ctorParameters = function () { return [
    { type: undefined, decorators: [{ type: core.Inject, args: [NGXS_DEVTOOLS_OPTIONS,] },] },
    { type: StateStream, },
]; };
var NgxsReduxDevtoolsPluginModule = /** @class */ (function () {
    function NgxsReduxDevtoolsPluginModule() {
    }
    NgxsReduxDevtoolsPluginModule.forRoot = function (options) {
        return {
            ngModule: NgxsReduxDevtoolsPluginModule,
            providers: [
                { provide: NGXS_PLUGINS, useClass: NgxsReduxDevtoolsPlugin, multi: true },
                { provide: NGXS_DEVTOOLS_OPTIONS, useValue: options ? options : {} }
            ]
        };
    };
    return NgxsReduxDevtoolsPluginModule;
}());
NgxsReduxDevtoolsPluginModule.decorators = [
    { type: core.NgModule, args: [{
                imports: [NgxsModule]
            },] },
];
NgxsReduxDevtoolsPluginModule.ctorParameters = function () { return []; };
var NGXS_LOGGER_PLUGIN_OPTIONS = new core.InjectionToken('NGXS_LOGGER_PLUGIN_OPTIONS');
var repeat = function (str, times) { return new Array(times + 1).join(str); };
var pad = function (num, maxLength) { return repeat('0', maxLength - num.toString().length) + num; };
var NgxsLoggerPlugin = /** @class */ (function () {
    function NgxsLoggerPlugin(_options) {
        this._options = _options;
    }
    NgxsLoggerPlugin.prototype.handle = function (state, event, next) {
        var options = this._options || ({});
        var logger = options.logger || console;
        var actionName = getTypeFromInstance(event);
        var time = new Date();
        var formattedTime = " @ " + pad(time.getHours(), 2) + ":" + pad(time.getMinutes(), 2) + ":" + pad(time.getSeconds(), 2) + "." + pad(time.getMilliseconds(), 3);
        var message = "action " + actionName + formattedTime;
        var startMessage = options.collapsed ? logger.groupCollapsed : logger.group;
        try {
            startMessage.call(logger, message);
        }
        catch (e) {
            console.log(message);
        }
        if (typeof event.payload !== 'undefined') {
            logger.log('%c payload', 'color: #9E9E9E; font-weight: bold', event.payload);
        }
        logger.log('%c prev state', 'color: #9E9E9E; font-weight: bold', state);
        var res = next(state, event);
        res.subscribe(function (nextState) {
            logger.log('%c next state', 'color: #4CAF50; font-weight: bold', nextState);
            try {
                logger.groupEnd();
            }
            catch (e) {
                logger.log('—— log end ——');
            }
        });
        return res;
    };
    return NgxsLoggerPlugin;
}());
NgxsLoggerPlugin.decorators = [
    { type: core.Injectable },
];
NgxsLoggerPlugin.ctorParameters = function () { return [
    { type: undefined, decorators: [{ type: core.Inject, args: [NGXS_LOGGER_PLUGIN_OPTIONS,] },] },
]; };
var NgxsLoggerPluginModule = /** @class */ (function () {
    function NgxsLoggerPluginModule() {
    }
    NgxsLoggerPluginModule.forRoot = function (options) {
        return {
            ngModule: NgxsLoggerPluginModule,
            providers: [
                {
                    provide: NGXS_PLUGINS,
                    useClass: NgxsLoggerPlugin,
                    multi: true
                },
                {
                    provide: NGXS_LOGGER_PLUGIN_OPTIONS,
                    useValue: Object.assign({
                        logger: console,
                        collapsed: false
                    }, options)
                }
            ]
        };
    };
    return NgxsLoggerPluginModule;
}());
NgxsLoggerPluginModule.decorators = [
    { type: core.NgModule },
];
NgxsLoggerPluginModule.ctorParameters = function () { return []; };
var NGXS_LOCAL_STORAGE_PLUGIN_OPTIONS = new core.InjectionToken('NGXS_LOCAL_STORAGE_PLUGIN_OPTION');
var NgxsLocalStoragePlugin = /** @class */ (function () {
    function NgxsLocalStoragePlugin(_options) {
        this._options = _options;
    }
    NgxsLocalStoragePlugin.prototype.handle = function (state, event, next) {
        var options = this._options || ({});
        var isInitAction = getTypeFromInstance(event) === '@@INIT';
        var keys = Array.isArray(options.key) ? options.key : [options.key];
        var engine = options.storage || localStorage;
        if (isInitAction) {
            try {
                for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
                    var key = keys_1_1.value;
                    var val = engine.getItem(key);
                    if (val !== 'undefined' && val !== null) {
                        val = options.deserialize(val);
                        if (key !== '@@STATE') {
                            state = setValue(state, key, val);
                        }
                        else {
                            state = val;
                        }
                    }
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);
                }
                finally { if (e_6) throw e_6.error; }
            }
        }
        var res = next(state, event);
        res.subscribe(function (nextState) {
            if (!isInitAction) {
                try {
                    for (var keys_2 = __values(keys), keys_2_1 = keys_2.next(); !keys_2_1.done; keys_2_1 = keys_2.next()) {
                        var key = keys_2_1.value;
                        var val = nextState;
                        if (key !== '@@STATE') {
                            val = getValue(nextState, key);
                        }
                        engine.setItem(key, options.serialize(val));
                    }
                }
                catch (e_7_1) { e_7 = { error: e_7_1 }; }
                finally {
                    try {
                        if (keys_2_1 && !keys_2_1.done && (_a = keys_2.return)) _a.call(keys_2);
                    }
                    finally { if (e_7) throw e_7.error; }
                }
            }
            var e_7, _a;
        });
        return res;
        var e_6, _a;
    };
    return NgxsLocalStoragePlugin;
}());
NgxsLocalStoragePlugin.decorators = [
    { type: core.Injectable },
];
NgxsLocalStoragePlugin.ctorParameters = function () { return [
    { type: undefined, decorators: [{ type: core.Inject, args: [NGXS_LOCAL_STORAGE_PLUGIN_OPTIONS,] },] },
]; };
function serialize(val) {
    return JSON.stringify(val);
}
function deserialize(val) {
    return JSON.parse(val);
}
var NgxsLocalStoragePluginModule = /** @class */ (function () {
    function NgxsLocalStoragePluginModule() {
    }
    NgxsLocalStoragePluginModule.forRoot = function (options) {
        if (options === void 0) { options = {}; }
        return {
            ngModule: NgxsLocalStoragePluginModule,
            providers: [
                {
                    provide: NGXS_PLUGINS,
                    useClass: NgxsLocalStoragePlugin,
                    multi: true
                },
                {
                    provide: NGXS_LOCAL_STORAGE_PLUGIN_OPTIONS,
                    useValue: {
                        key: options.key || '@@STATE',
                        storage: localStorage,
                        serialize: options.serialize || serialize,
                        deserialize: options.deserialize || deserialize
                    }
                }
            ]
        };
    };
    return NgxsLocalStoragePluginModule;
}());
NgxsLocalStoragePluginModule.decorators = [
    { type: core.NgModule },
];
NgxsLocalStoragePluginModule.ctorParameters = function () { return []; };

exports.NgxsModule = NgxsModule;
exports.Action = Action;
exports.Store = Store;
exports.State = State;
exports.Select = Select;
exports.Actions = Actions;
exports.ofAction = ofAction;
exports.Selector = Selector;
exports.NgxsReduxDevtoolsPlugin = NgxsReduxDevtoolsPlugin;
exports.NgxsReduxDevtoolsPluginModule = NgxsReduxDevtoolsPluginModule;
exports.NgxsLoggerPlugin = NgxsLoggerPlugin;
exports.NgxsLoggerPluginModule = NgxsLoggerPluginModule;
exports.NgxsLocalStoragePlugin = NgxsLocalStoragePlugin;
exports.NgxsLocalStoragePluginModule = NgxsLocalStoragePluginModule;
exports.ɵb = NgxsFeatureModule;
exports.ɵa = NgxsRootModule;
exports.ɵi = PluginManager;
exports.ɵk = NGXS_DEVTOOLS_OPTIONS;
exports.ɵo = NGXS_LOCAL_STORAGE_PLUGIN_OPTIONS;
exports.ɵq = deserialize;
exports.ɵp = serialize;
exports.ɵm = NGXS_LOGGER_PLUGIN_OPTIONS;
exports.ɵc = SelectFactory;
exports.ɵg = StateFactory;
exports.ɵh = StateStream;
exports.ɵe = FEATURE_STATE_TOKEN;
exports.ɵf = NGXS_PLUGINS;
exports.ɵd = ROOT_STATE_TOKEN;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngxs-api.umd.js.map
